
<!DOCTYPE html>
<html lang="ja-jp">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="b4b4r07, babarot" name="keywords">
<meta content="b4b4r07" name="author">
<meta property="og:title" content="hashicorp/hcl2 を使って独自 DSL を定義する - tellme.tokyo">
<meta property="og:url" content="https://tellme.tokyo/post/2019/02/19/hashicorp-hcl2/">
<meta property="og:description" content="tellme.tokyo">
<meta property="og:type" content="website" />

<meta property="og:image" content="https://raw.githubusercontent.com/b4b4r07/tellme.tokyo/master/static/images/profile.jpg">
<meta name="twitter:image" content="https://raw.githubusercontent.com/b4b4r07/tellme.tokyo/master/static/images/profile.jpg">

<title>hashicorp/hcl2 を使って独自 DSL を定義する | tellme.tokyo</title>
<link rel="stylesheet" href="https://tellme.tokyo/css/style.css">
<link rel="stylesheet" href="https://tellme.tokyo/css/custom.css">
<link rel="shortcut icon" href="https://tellme.tokyo/favicon.ico">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://tellme.tokyo"><h1 class="title is-4">tellme.tokyo</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/b4b4r07" target="_blank">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/b4b4r07" target="_blank">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">hashicorp/hcl2 を使って独自 DSL を定義する</h1>
    <h2 class="subtitle is-5">February 19, 2019 </h2>
    
      <div class="tags">
    
        <a class="button is-link" href="/tags/go">go</a>
    
        <a class="button is-link" href="/tags/hashicorp">hashicorp</a>
    
        <a class="button is-link" href="/tags/hcl">hcl</a>
    
        <a class="button is-link" href="/tags/hcl2">hcl2</a>
    
</div>

    
    <br>
    <div class="content">
      
      

<h2 id="hcl2-とは">HCL2 とは</h2>

<p>HCL (HashiCorp Configuration Language) は HashiCorp によって作られた設定言語です。
HCL の目的はコマンドラインツールで使用するために、人間からも機械からも扱いやすく構成されていて、かつ特に DevOps ツールやサーバーなどを対象とした構造化構成言語であることです。</p>

<p>実装は <a href="https://github.com/hashicorp/hcl">hashicorp/hcl</a> にあります。</p>

<p>実はこれの他に同時に Version 2 の実装も目下開発中のようです。</p>

<p><a href="https://github.com/hashicorp/hcl2">hashicorp/hcl2: Temporary home for experimental new version of HCL</a></p>

<p>このリポジトリでは HCL が元から持つ iteration と補間言語 HIL を組み合わせて、任意の式をサポートする単一の構成言語を目指しているようです。
要するに、設定ファイルでありながら、演算処理や式の評価といったプログラミング言語的な要素を持ち合わせます。</p>

<p>ちなみに、HCL は HCL2 との互換性は保証されていないため、application から使用する場合は latest ではなく vendoring したものを参照するのが好ましいです。
また、HCL から HCL2 への移行パスは想定されていないようです。
構文の見た目上は非常に似ておりベースデザインは元実装を引き継ぎつつも、拡張された部分については全く異なるアプローチで実装されているようです。
例えば HCL2 の実装の方はより堅牢なエラー処理を可能にする機能などが盛り込まれています。
HCL2 の開発が安定したらもとのリポジトリはアーカイブされ、こちらが HCL の本実装になるようです。</p>

<p>ちなみに、HCL2 を含んだ HCL 全体のデザインなどは次の PDF が参考になります。</p>

<p><a href="https://media.readthedocs.org/pdf/hcl/guide/hcl.pdf">HCL Documentation</a></p>

<h2 id="hcl2-の機能">HCL2 の機能</h2>

<p>JSON や YAML のパーサでは、バイト列を Go の構造体に落とし込むことで各要素を Go プログラム内から扱えるようにしています。</p>

<p>HCL でも同様のアプローチを取りますが、内部で中間表現として別の Go 構造体に落とし込んでいます。
具体的に Decode (HCL ファイルから Go 構造体に落とし込む) までの流れを見てみます。</p>

<link href="/mermaid/mermaid.css" type="text/css" rel="stylesheet"/>
<script defer src="/mermaid/mermaid.js">mermaid.initialize({startOnLoad:true});</script>
<div class="mermaid" align="center" >
graph TB;
  hcl(HCL)   -- "hclparse.ParseHCL()"  --> file1("hcl.File")
  json(JSON) -- "hclparse.ParseJSON()" --> file2("hcl.File")
  file1      -- "hcl.MergeFiles()"     --> body((hcl.File))
  file2      -- "hcl.MergeFiles()"     --> body((hcl.File))
  body       -- "gohcl.DecodeBody()"   --> struct("struct")
</div>


<p>HCL は JSON と互換性を持つので、hcl2 は両ファイル形式をサポートします。
HCL が読み込まれると <a href="https://godoc.org/github.com/hashicorp/hcl2/hclparse#Parser.ParseHCL"><code>hclparse.ParseHCL()</code></a> によって <a href="https://godoc.org/github.com/hashicorp/hcl2/hcl#File">hcl.File</a> に変換されます。
HCL はその特性上ファイル分割されていても一つにマージして内部で扱うことができます (<code>terraform plan</code> するときにカレントディレクトリ内の <code>*.tf</code> ファイルが対象となって実行されるイメージ)。</p>

<p><a href="https://godoc.org/github.com/hashicorp/hcl2/hcl#MergeFiles"><code>hcl.MergeFiles()</code></a> によって複数の hcl.File をマージして構造体に落とし込むこともできます。</p>

<p>そのあと、実際にデコード処理の部分として、<a href="https://godoc.org/github.com/hashicorp/hcl2/gohcl#DecodeBody"><code>gohcl.DecodeBody()</code></a> を使って任意の構造体に変換できます。</p>

<p>ここからが hcl2 の面白い部分の一つです。中間表現をもつことで、デコード前にいろいろな処理を挟むことができるようになっています。
具体的には <a href="https://godoc.org/github.com/hashicorp/hcl2/hcl#EvalContext">hcl.EvalContext</a> です。</p>

<pre><code class="language-go">type EvalContext struct {
	Variables map[string]cty.Value
	Functions map[string]function.Function
	parent    *EvalContext
}
</code></pre>

<p>hcl.EvalContext は変数マップと関数マップを定義した構造体になっていて、<code>gohcl.DecodeBody()</code> にわたすことができます。
これによって任意の文字列をデコードのときにスキーマ側で定義済みの変数、もしくは関数として展開することができます。
つまり以下のようなコンテキスト情報をもとに、デコードのときに文字列 (&ldquo;upper&rdquo; など) を置換して map の value として評価することができます。</p>

<pre><code class="language-go">ctx := &amp;hcl.EvalContext{
	Variables: map[string]cty.Value{
		&quot;name&quot;: cty.StringVal(&quot;Ermintrude&quot;),
	},
	Functions: map[string]function.Function{
		&quot;upper&quot;:  stdlib.UpperFunc,
		&quot;lower&quot;:  stdlib.LowerFunc,
		&quot;min&quot;:    stdlib.MinFunc,
		&quot;max&quot;:    stdlib.MaxFunc,
		&quot;strlen&quot;: stdlib.StrlenFunc,
		&quot;substr&quot;: stdlib.SubstrFunc,
	},
}
</code></pre>

<pre><code class="language-hcl">message = &quot;HELLO, ${upper(name)}!&quot;
# ==&gt; &quot;HELLO, ERMINTRUDE!&quot;
</code></pre>

<p>Terraform ユーザは分かると思いますが、Terraform の tf ファイルでさまざまな組み込み関数がサポートされているのもこの機能によって実現されています。</p>

<ul>
<li><a href="https://www.terraform.io/docs/configuration/interpolation.html">Interpolation Syntax</a></li>
<li><a href="https://github.com/hashicorp/terraform/blob/master/lang/functions.go">lang/functions.go - hashicorp/terraform</a></li>
</ul>

<pre><code class="language-hcl">resource &quot;aws_instance&quot; &quot;app&quot; {
  count = &quot;3&quot;
  private_ip = &quot;${lookup(var.instance_ips, count.index)}&quot;
  # ...
}
</code></pre>

<p>Terraform では <a href="https://www.terraform.io/docs/configuration/interpolation.html#lookup-map-key-default-">lookup</a> などが Terraform が提供する組み込み関数として定義されており、デコードする前に、つまりスキーマに対応する構造体などに変換される前にこれらがコンテキストとして渡されて評価されるため、実際には以下のような Go 関数が実行されるので、lookup があたかも 関数であるかのように HCL ファイル内で作用させることができます。</p>

<pre><code class="language-go">var LookupFunc = function.New(&amp;function.Spec{
	Params: []function.Parameter{
		...
	},
	VarParam: &amp;function.Parameter{
		...
	},
	Type: func(args []cty.Value) (ret cty.Type, err error) {
		...
	},
	Impl: func(args []cty.Value, retType cty.Type) (ret cty.Value, err error) {
		...
	},
})
</code></pre>

<p>これ以外にも面白い機能がたくさんあります。</p>

<p><a href="https://github.com/hashicorp/hcl2/tree/master/guide">hcl2/guide at master · hashicorp/hcl2</a></p>

<p>公式リポジトリに guide 以下が参考になります。</p>

<h2 id="dsl-を定義する">DSL を定義する</h2>

<p>表題にある通り HCL ベースの DSL をつくりましょう。上で書いたとおり、HCL2 では任意の関数などを定義した上で独自の DSL を定義できます。
具体例をあげると、Terraform の <a href="https://www.terraform.io/docs/configuration/resources.html">resource</a> ブロックのような感じで独自のスキーマを定義した上で、任意の変数・関数を組み込みとして提供する DSL を自身のプロダクトの設定ファイルに持ち込むことができます。</p>

<p>これは結構すごいことだと思うんです。</p>

<p>例えば、rule というスキーマを定義したとします。あとはそのスキーマを含めて提供する DSL として必要な関数や変数をデザインしてコンテキストとして織り込むだけで拡張可能な設定ファイルを作り上げることができます。</p>

<pre><code class="language-hcl">rule &quot;replicas&quot; {
  description = &quot;Check the number of replicas is sufficient&quot;

  conditions = [
    &quot;${jsonpath(&quot;.spec.replicas&quot;) &gt; 3}&quot;,
  ]

  report {
    level   = &quot;ERROR&quot;
    message = &quot;Too few replicas&quot;
  }
}
</code></pre>

<p>上の例では、jsonpath を取得する関数を定義しています。</p>

<p>ここからは実際の例を見ていきます。
stein という YAML ファイルなどの設定ファイル言語に対して任意のルールセットによってテストするツールで用いられている HCL ベースの DSL を例に説明していきます。</p>

<p><a href="https://github.com/b4b4r07/stein/">b4b4r07/stein: A linter for config files with a customizable rule set</a></p>

<p>上で述べたように、hcl.File での中間表現を経由して構造体に落とし込まれる過程を次のように表します。</p>

<link href="/mermaid/mermaid.css" type="text/css" rel="stylesheet"/>
<script defer src="/mermaid/mermaid.js">mermaid.initialize({startOnLoad:true});</script>
<div class="mermaid" align="center" >
graph TB;
  hcl(HCL)   -- "hclparse.ParseHCL()"  --> file("hcl.File")
  file       -- "gohcl.DecodeBody()"   --> struct("struct")
</div>


<p>まずはじめに、<code>hclparse.ParseHCL()</code> の部分です。
ソースコードからスキーマの定義を見ていきましょう。スキーマは HCL を hcl.File にパースする際に使用します。
このレイヤーでは &ldquo;DSL レベル&rdquo; でのバリデーションを設けることができます。
例えば、「config ブロックは label (ブロック横の名付け) を取らない」や「rule ブロック内の report ブロックの level 属性は必須項目である」など。
これに違反した場合、hcl.Diagnostic としてレポートすることができます。</p>

<pre><code class="language-go">var policySchema = &amp;hcl.BodySchema{
	Blocks: []hcl.BlockHeaderSchema{
		{
			Type:       &quot;rule&quot;,
			LabelNames: []string{&quot;name&quot;},
		},
		{
			Type: &quot;config&quot;,
		},
		{
			Type:       &quot;function&quot;,
			LabelNames: []string{&quot;name&quot;},
		},
		{
			Type:       &quot;variable&quot;,
			LabelNames: []string{&quot;name&quot;},
		},
	},
}
</code></pre>

<p>次に、<code>gohcl.DecodeBody()</code> の部分です。</p>

<p>スキーマをもとに <code>hclparse.ParseHCL()</code> によってパースされた HCL は hcl.File になります。</p>

<pre><code class="language-go">// https://github.com/b4b4r07/stein/blob/fc9549f9db0f982f2756ef97a643ca9394de337e/lint/lint.go#L112-L117
ctx, diags := l.policy.BuildContext(l.body, file.Path, file.Data)
if diags.HasErrors() {
	return policy, diags
}

decodeDiags := gohcl.DecodeBody(l.body, ctx, &amp;policy)
</code></pre>

<p>hcl.File は hcl.EvalContext とともに <code>gohcl.DecodeBody()</code> によって <code>policy</code> 構造体にデコードされます。</p>

<p>ここのレイヤーでもバリデーションが実施されます。Marshal/Unmarshal の部分です。</p>

<pre><code class="language-go">// https://github.com/b4b4r07/stein/blob/fc9549f9db0f982f2756ef97a643ca9394de337e/lint/policy.go#L10-L18
type Policy struct {
	Config  *Config  `hcl:&quot;config,block&quot;`
	Rules   Rules    `hcl:&quot;rule,block&quot;`

	Remain hcl.Body `hcl:&quot;,remain&quot;`
}
</code></pre>

<p>この Policy 構造体が実際に Go プログラム内で扱うものになります。
JSON/YAML などで使う struct tag でバインドの設定をしていきます。</p>

<p>ちなみに、optional のフラグもありますが、block と併用する場合ポインタにして nil として扱う必要があります。</p>

<ul>
<li><a href="https://github.com/hashicorp/hcl2/pull/13">Added struct tag optional for gohcl by nicholasjackson · Pull Request #13 · hashicorp/hcl2</a></li>
<li><a href="https://github.com/hashicorp/hcl2/issues/24">gohcl and optional attributes · Issue #24 · hashicorp/hcl2</a></li>
</ul>

<p>これらの流れを踏まえて stein では、</p>

<pre><code class="language-console">$ tree -d ./lint
lint/
├── args.go
├── lint.go                  &lt;---- (2) gohcl.DecodeBody() の実行
├── policy.go                &lt;---- * decode される構造体の定義
└── internal/
     └── policy/
          ├── funcs/
          ├── loader/        &lt;---- (1) HCL を読み込む
          ├── terraform/
          ├── config.go
          ├── context.go
          ├── policy.go      &lt;---- * スキーマの定義
          ├── rule.go
          └── variable.go
</code></pre>

<p>という形でパッケージングしています。</p>

<h2 id="まとめ">まとめ</h2>

<p>本記事では hashicorp/hcl2 パッケージを紹介するとともに以下の2点に焦点を当てて取り上げました。</p>

<ul>
<li>独自のスキーマを定義、それをもとにパースしバリデーション違反を Diagnostic としてレポートできる</li>
<li>EvalContext によって組み込み提供する変数、関数を実装できる</li>
</ul>

<p>HCL での設定において、hcl2 を用いてスキーマ定義・言語拡張を行うことで Terraform のような幅広い表現力を手に入れることができます。</p>

<p>ちなみに、Diagnostic でレポートされた診断結果は hcl2 パッケージの <a href="https://godoc.org/github.com/hashicorp/hcl2/hcl#DiagnosticWriter">hcl.DiagnosticWriter</a> によって以下のようにわかりやすくエラー診断を表示することができます。</p>

<pre><code>Error: Unsupported argument

  on _examples/.policy/config.hcl line 2, in config:
   2:   foo = &quot;test&quot;

An argument named &quot;foo&quot; is not expected here.
</code></pre>

<p>もちろんこの診断結果も&rdquo;DSL レベル&rdquo;で実装者が定義できます。</p>

<p>hcl2 はまだ開発途中ですが強力な表現力を提供することが可能なので、ユーザに強く設定ファイルを書かせたい場合<sup class="footnote-ref" id="fnref:1"><a href="#fn:1">1</a></sup>にはいい選択肢となると思います。</p>
<div class="footnotes">

<hr />

<ol>
<li id="fn:1">stein はテストルールをユーザのユースケースに合わせて定義してもらい、それをもとに lint を実行するツールなので hcl2 との相性が抜群でした
 <a class="footnote-return" href="#fnref:1"><sup>[return]</sup></a></li>
</ol>
</div>

    </div>
    <br>
    <div class="social">
  
  
    
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="b4b4r07" data-count="horizontal" lang="en">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  
  
    
      <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    
  
  
  
</div>

  </div>
</section>


<section class="section">
  <div class="container has-text-centered header-logo">
    <a href="https://tellme.tokyo"><img src="/images/profile.jpg" width="64" height="64"></a><br><br>
    <p>Copyright &copy; 2019 BABAROT All Right Reserved.</p>
  </div>
</section>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/dockerfile.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-44183504-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



