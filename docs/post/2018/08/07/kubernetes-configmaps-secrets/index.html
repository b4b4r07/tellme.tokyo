
<!DOCTYPE html>
<html lang="ja-jp">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta content="b4b4r07, babarot" name="keywords">
<meta content="b4b4r07" name="author">
<meta property="og:title" content="Kubernetes 上で Credentials を扱う - tellme.tokyo">
<meta property="og:url" content="https://tellme.tokyo/post/2018/08/07/kubernetes-configmaps-secrets/">
<meta property="og:description" content="tellme.tokyo">
<meta property="og:type" content="website" />

<meta property="og:image" content="https://raw.githubusercontent.com/b4b4r07/tellme.tokyo/master/static/images/profile.jpg">
<meta name="twitter:image" content="https://raw.githubusercontent.com/b4b4r07/tellme.tokyo/master/static/images/profile.jpg">

<title>Kubernetes 上で Credentials を扱う | tellme.tokyo</title>
<link rel="stylesheet" href="https://tellme.tokyo/css/style.css">
<link rel="stylesheet" href="https://tellme.tokyo/css/custom.css">
<link rel="shortcut icon" href="https://tellme.tokyo/favicon.ico">
<link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">

<link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/styles/github.min.css">


<section class="section">
  <div class="container">
    <nav class="nav">
      <div class="nav-left">
        <a class="nav-item" href="https://tellme.tokyo"><h1 class="title is-4">tellme.tokyo</h1></a>
      </div>
      <div class="nav-right">
        <nav class="nav-item level is-mobile">
          
          <a class="level-item" href="https://github.com/b4b4r07" target="_blank">
            <span class="icon">
              <i class="fa fa-github"></i>
            </span>
          </a>
          
          <a class="level-item" href="https://twitter.com/b4b4r07" target="_blank">
            <span class="icon">
              <i class="fa fa-twitter"></i>
            </span>
          </a>
          
        </nav>
      </div>
    </nav>
  </div>
</section>

<section class="section">
  <div class="container">
    <h1 class="title">Kubernetes 上で Credentials を扱う</h1>
    <h2 class="subtitle is-5">August 7, 2018 </h2>
    
      <div class="tags">
    
        <a class="button is-link" href="/tags/kubernetes">kubernetes</a>
    
        <a class="button is-link" href="/tags/kubernetes-configmaps">kubernetes-configmaps</a>
    
        <a class="button is-link" href="/tags/kubernetes-secrets">kubernetes-secrets</a>
    
</div>

    
    <br>
    <div class="content">
      
      

<p>アプリケーションにロジックを外側から変更したい場合やソースコード外から設定されるべき情報 (API キーや何らかのトークン、その他の Credentials など) をアプリケーション側から読み取れるようにしたい場合がある。
よくある方法として、環境変数やフラグなどがある。</p>

<p>しかしこれらは往々にしてアプリケーションにハードコードされがちである (ロジックが書かれたファイル外に定義されたとしてもそれはハードコードに等しい)。
そうすると設定変更のたびにデプロイを必要とするし、言わずもがなセキュリティ的には厳しい。</p>

<p>またこの問題は、コンテナとマイクロサービスの領域において更に顕著になる。
同じデータを2つの異なるコンテナで参照する必要がある場合や、ホストマシンが使えないのでどうやってコンテナ内に渡すべきかを考える必要が出てくる。</p>

<p>実際にハードコードされたアプリケーションから環境変数に移し、それらをコンテナ化し Kubernetes に載せ替えてくステップを追う。</p>

<h2 id="アプリ側にハードコードされた例">アプリ側にハードコードされた例</h2>

<pre><code class="language-js">var http = require('http');
var server = http.createServer(function (request, response) {
  const language = 'English';
  const API_KEY = '123-456-789';
  response.write(`Language: ${language}\n`);
  response.write(`API Key: ${API_KEY}\n`);
  response.end(`\n`);
});
server.listen(3000);
</code></pre>

<p>language やAPI キーを変更する場合は、コードを編集する必要がある。
またバグやセキュリティリーク、ソースコードの履歴を汚すアプローチである。</p>

<p>これの代わりに環境変数を使う。</p>

<h2 id="環境変数を使うパターン">環境変数を使うパターン</h2>

<h3 id="step-1-環境変数を読み込む">Step 1: 環境変数を読み込む</h3>

<pre><code class="language-js">var http = require('http');
var server = http.createServer(function (request, response) {
  const language = process.env.LANGUAGE;
  const API_KEY = process.env.API_KEY;
  response.write(`Language: ${language}\n`);
  response.write(`API Key: ${API_KEY}\n`);
  response.end(`\n`);
});
server.listen(3000);
</code></pre>

<p>環境変数を設定できるので、アプリケーションのコードに触れる必要はなくなる。</p>

<p>次のようにして現在のセッションの環境変数を設定できる。</p>

<pre><code class="language-bash">export LANGUAGE=&quot;English&quot;
export API_KEY=&quot;123-456-789&quot;
</code></pre>

<h3 id="step-2-docker-の環境変数にする">Step 2: Docker の環境変数にする</h3>

<p>アプリケーションがコンテナ化されると、ホストの環境変数に依存しなくなる。
逆に言うとコンテナに閉じた環境内で正しく設定される必要がある。
これは Dockerfile の <code>ENV</code> ディレクティブで指定できる。</p>

<pre><code class="language-dockerfile">FROM node:6-onbuild
EXPOSE 3000
ENV LANGUAGE English
ENV API_KEY 123-456-789
</code></pre>

<p>これを Dockerfile として保存してコードと同じディレクトリに置いてビルドする。</p>

<pre><code class="language-bash"># ビルド
docker build -t envtest .
# 実行
docker run -p 3000:3000 -ti envtest
</code></pre>

<h3 id="step-3-kubernetes-の環境変数にする">Step 3: Kubernetes の環境変数にする</h3>

<p>Docker コンテナを Kubernetes に移す。</p>

<p>Dockerfile と同様に、Kubernetes Deployment の YAML ファイルに直接環境変数を指定できる。</p>

<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: envtest
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: envtest
    spec:
      containers:
      - name: envtest
        image: gcr.io/&lt;PROJECT_ID&gt;/envtest
        ports:
        - containerPort: 3000
        env:
        - name: LANGUAGE
          value: &quot;English&quot;
        - name: API_KEY
          value: &quot;123-456-789&quot;
</code></pre>

<h3 id="step-4-kubernetes-secrets-と-configmaps">Step 4: Kubernetes Secrets と ConfigMaps</h3>

<p>Docker コンテナや Kubernetes での環境変数から設定を行う場合、コンテナや Deployment でのやり方に縛られてしまうという欠点がある。
環境変数を変更する場合は、コンテナを再ビルドするか、Deployment を変更する必要がでてくる。
また、この環境変数を他のコンテナや Deployment でも使用したい場合は、変数部分をコピペしていく必要がある。</p>

<p>しかし、Kubernetes は Secrets（機密データ用）と ConfigMaps（非機密データ用）という機能を持ってこれを解決している。</p>

<p>Secrets と ConfigMaps の大きな違いは、Secrets は Base64 エンコーディングで難読化されていること。
今後、Kubernetes のアップデートによって違いが出てくるかも知れないが、機密データ（API キーなど）は Secret に、非機密データ（ポート番号など）は ConfigMap という使い分けでいいと思う。</p>

<pre><code class="language-bash"># API_KEY を Secret に保存する
kubectl create secret generic apikey --from-literal=API_KEY=123–456
# LANGUAGE を ConfigMap に保存する
kubectl create configmap language --from-literal=LANGUAGE=English
</code></pre>

<p>次のコマンドでこれらが作成されていることを確認できる。</p>

<pre><code class="language-bash">$ kubectl get secret
NAME                  TYPE                                  DATA      AGE
apikey                Opaque                                0         45s
default-token-gfzcr   kubernetes.io/service-account-token   3         11d

$ kubectl get configmap
NAME       DATA     AGE
language   1        1m
</code></pre>

<p>こうすることで Deployment の YAML にハードコードする必要がなくなる。</p>

<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: envtest
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: envtest
    spec:
      containers:
      - name: envtest
        image: gcr.io/&lt;PROJECT_ID&gt;/envtest
        ports:
        - containerPort: 3000
        env:
        - name: API_KEY
          valueFrom:
            secretKeyRef:
              name: apikey
              key: API_KEY
        - name: LANGUAGE
          valueFrom:
            configMapKeyRef:
              name: language
              key: LANGUAGE
</code></pre>

<h2 id="secrets-と-configmaps-の更新">Secrets と ConfigMaps の更新</h2>

<p>Secret や ConfigMap を使って Kubernetes に環境変数を管理させれば、変数の値を変更するときにコードを変更したりコンテナを再ビルドしたりする必要がなくなる。</p>

<p>環境変数の変更は、Secret または ConfigMap を更新したあとに、Pod を再起動することでできる (Pod は起動時に環境変数の値をキャッシュしているため)。</p>

<p>まず、値を更新する。</p>

<pre><code class="language-bash">kubectl create configmap language --from-literal=LANGUAGE=Spanish -o yaml --dry-run \
    | kubectl replace -f -
kubectl create secret generic apikey --from-literal=API_KEY=098765 -o yaml --dry-run \
    | kubectl replace -f -
</code></pre>

<p>次に、Pod を再起動する。
これは、新しい Deployment を展開するなどがあるが、Pod を手動で削除することで Deployment に新しい Pod を自動で Rollout させるのが手っ取り早い。</p>

<pre><code class="language-bash">kubectl delete pod -l name=envtest
</code></pre>

<h2 id="設定をファイルから読む">設定をファイルから読む</h2>

<p>設定項目が多くない場合は環境変数は適しているが、アプリケーションに渡す必要のあるデータがたくさんあるときには向かない。
よくある解決策は、これらの設定を JSON/YAML/TOML などのファイルに落とし込み、そのファイルをアプリから読み込ませる手法などがある。</p>

<p>Kubernetes は ConfigMaps とSecrets をファイルとしてマウントさせることができる。
環境変数とは異なり、これらのファイルが変更されると、新しいファイルは再起動を必要とせずに実行中の Pod にプッシュされる。
また、複数の Config が置かれたディレクトリをマウントし、Secret/ConfigMap とすることもできる。</p>

<pre><code class="language-bash">mkdir config &amp;&amp; mkdir secret
echo '{&quot;LANGUAGE&quot;:&quot;English&quot;}' &gt; ./config/config.json
echo '{&quot;API_KEY&quot;:&quot;123-456-789&quot;}' &gt; ./secret/secret.json
</code></pre>

<p>これに合わせて環境変数ではなくファイルから設定を読むようにアプリケーション側を変更しておく。</p>

<pre><code class="language-js">var http = require('http');
var fs = require('fs');
var server = http.createServer(function (request, response) {
  fs.readFile('./config/config.json', function (err, config) {
    if (err) return console.log(err);
    const language = JSON.parse(config).LANGUAGE;
    fs.readFile('./secret/secret.json', function (err, secret) {
      if (err) return console.log(err);
      const API_KEY = JSON.parse(secret).API_KEY;
      response.write(`Language: ${language}\n`);
      response.write(`API Key: ${API_KEY}\n`);
      response.end(`\n`);
    });
  });
});
server.listen(3000);
</code></pre>

<blockquote>
<p><em>注: このコードはすべてのリクエストに対してファイルを再読み込みする。プログラムの起動時に一度ファイルを読み込むようにするとファイルの更新は取得されず、ファイルを更新するためにコンテナを再起動する必要がでてくる</em></p>
</blockquote>

<h2 id="docker-volumes-を使ってファイルをマウントする">Docker volumes を使ってファイルをマウントする</h2>

<p>ローカルで簡単に試す方法として Docker ボリュームを使って ConfigMaps と Secrets をシミュレートできる。</p>

<pre><code class="language-bash"># ビルド
docker build -t envtest .
# 実行
docker run -p 3000:3000 -ti \
  -v $(pwd)/secret/:/usr/src/app/secret/ \
  -v $(pwd)/config/:/usr/src/app/config/ \
  envtest
</code></pre>

<blockquote>
<p><em>注: <a href="https://github.com/nodejs/docker-node/blob/master/6/onbuild/Dockerfile#4">onbuild コンテナ</a>は、コードを <code>/usr/src/app</code> ディレクトリに置くため、そこに対してマウントしている</em></p>
</blockquote>

<p><code>localhost:3000</code> にアクセスすると次にようになる。</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*qqUtUpXoe9DRiMUtcrf0kw.png" alt="" /></p>

<p>ファイルはコンテナにマウントされており、コードはリクエストごとにファイルを再読み込みするため、ファイルを変更して再起動せずに変更を確認できる。</p>

<pre><code class="language-bash">echo '{&quot;LANGUAGE&quot;:&quot;Spanish&quot;}' &gt; ./config/config.json
</code></pre>

<p><img src="https://cdn-images-1.medium.com/max/800/1*j_sIOIcnmgevdo7zI__XEA.png" alt="" /></p>

<h2 id="ファイルから-secret-と-configmap-を作成する">ファイルから Secret と ConfigMap を作成する</h2>

<p>値から Secret/ConfigMap を作成したように、ファイルをデータソースとして作成することもできる。</p>

<pre><code class="language-bash"># ファイルから Secret を作成
kubectl create secret generic my-secret --from-file=./secret/secret.json
# ファイルから ConfigMap を作成
kubectl create configmap my-config --from-file=./config/config.json
</code></pre>

<h2 id="secret-と-configmap-をファイルとして使う">Secret と ConfigMap をファイルとして使う</h2>

<p>最後に環境変数の代わりに Secret と ConfigMap をファイルとして使用する Deployment を作成する。</p>

<p>Deployment YAML では、Secret と ConfigMap をボリュームとして使用できる。
これにより、Docker の場合と同様に、コンテナ内のディレクトリにマウントされる。</p>

<pre><code class="language-yaml">apiVersion: extensions/v1beta1
kind: Deployment
metadata:
  name: envtest
spec:
  replicas: 1
  template:
    metadata:
      labels:
        name: envtest
    spec:
      containers:
      - name: envtest
        image: gcr.io/smart-spark-93622/envtest:file5
        ports:
        - containerPort: 3000
        volumeMounts:
          - name: my-config
            mountPath: /usr/src/app/config
          - name: my-secret
            mountPath: /usr/src/app/secret
      volumes:
      - name: my-config
        configMap:
          name: my-config
      - name: my-secret
        secret:
          secretName: my-secret
</code></pre>

<h2 id="動的に更新">動的に更新</h2>

<p>ボリュームを使うことで動的に再マウントすることができる。
これは実行中のプロセスを再起動することなく、新しい Secret 値と ConfigMap 値がコンテナで使用可能になる。</p>

<p>たとえば、LANGUAGE を Klingon に変更し、ConfigMap を更新する。</p>

<pre><code class="language-bash">echo '{&quot;LANGUAGE&quot;:&quot;Klingon&quot;}' &gt; ./config/config.json
kubectl create configmap my-config \
  --from-file=./config/config.json \
  -o yaml --dry-run | kubectl replace -f -
</code></pre>

<p>数秒（キャッシュに応じて最大1分）で新しいファイルが自動的に実行中のコンテナにプッシュされる。</p>

<p><img src="https://cdn-images-1.medium.com/max/800/1*wGebNWPZ_I_x0ruXA0ttrQ.gif" alt="" /></p>

<h2 id="まとめ">まとめ</h2>

<ul>
<li>コンテナ化したアプリケーションへの設定注入は環境変数が良い</li>
<li>Dockerfile に書いてビルドするのではなく、Deployment 経由でプロセスに伝えるべき</li>
<li>Deployment YAML にハードコードするのではなく、Secret / ConfigMap 経由で伝えるべき</li>
<li>Secret / ConfigMap は Kubernetes の Key-value データストア (保存先は etcd) である</li>
<li>Secret / ConfigMap の違いは、

<ul>
<li>Secret: Base64 エンコードされるため、機密情報 (API ーなど) 向き</li>
<li>ConfigMap: 生データのまま保存されるため、それ以外の情報 (ポート番号など) 向き</li>
</ul></li>
<li>Secret / ConfigMap は値としてもファイルとしても作成できる</li>
</ul>

<h2 id="参考">参考</h2>

<ul>
<li><a href="https://medium.com/google-cloud/kubernetes-configmaps-and-secrets-68d061f7ab5b">https://medium.com/google-cloud/kubernetes-configmaps-and-secrets-68d061f7ab5b</a></li>
<li><a href="https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/">https://kubernetes.io/docs/tasks/configure-pod-container/configure-pod-configmap/</a></li>
<li><a href="https://vidhyachari.wordpress.com/2017/10/08/kubernetes-configmaps-and-secrets/">https://vidhyachari.wordpress.com/2017/10/08/kubernetes-configmaps-and-secrets/</a></li>
<li><a href="https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/">https://blog.giantswarm.io/understanding-basic-kubernetes-concepts-iv-secrets-and-configmaps/</a></li>
<li><a href="https://medium.com/@xcoulon/managing-pod-configuration-using-configmaps-and-secrets-in-kubernetes-93a2de9449be">https://medium.com/@xcoulon/managing-pod-configuration-using-configmaps-and-secrets-in-kubernetes-93a2de9449be</a></li>
<li><a href="https://ubiteku.oinker.me/2017/03/01/kubernetes-secrets/">https://ubiteku.oinker.me/2017/03/01/kubernetes-secrets/</a></li>
<li><a href="https://cloud.google.com/kubernetes-engine/docs/concepts/secret">https://cloud.google.com/kubernetes-engine/docs/concepts/secret</a></li>
</ul>

    </div>
    <br>
    <div class="social">
  
  
    
    <a href="https://twitter.com/share" class="twitter-share-button" data-via="b4b4r07" data-count="horizontal" lang="en">Tweet</a> <script>!function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0],p=/^http:/.test(d.location)?'http':'https';if(!d.getElementById(id)){js=d.createElement(s);js.id=id;js.src=p+'://platform.twitter.com/widgets.js';fjs.parentNode.insertBefore(js,fjs);}}(document, 'script', 'twitter-wjs');</script>
  
  
    
      <a href="http://b.hatena.ne.jp/entry/" class="hatena-bookmark-button" data-hatena-bookmark-layout="simple-balloon" title="このエントリーをはてなブックマークに追加"><img src="https://b.st-hatena.com/images/entry-button/button-only@2x.png" alt="このエントリーをはてなブックマークに追加" width="20" height="20" style="border: none;" /></a><script type="text/javascript" src="https://b.st-hatena.com/js/bookmark_button.js" charset="utf-8" async="async"></script>
    
  
  
  
</div>

  </div>
</section>


<section class="section">
  <div class="container has-text-centered header-logo">
    <a href="https://tellme.tokyo"><img src="/images/profile.jpg" width="64" height="64"></a><br><br>
    <p>Copyright &copy; 2019 BABAROT All Right Reserved.</p>
  </div>
</section>
<script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/highlight.min.js" integrity="sha256-KbfTjB0WZ8vvXngdpJGY3Yp3xKk+tttbqClO11anCIU=" crossorigin="anonymous"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/go.min.js"></script>

<script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.9.0/languages/dockerfile.min.js"></script>

<script>hljs.initHighlightingOnLoad();</script>


<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-44183504-2', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>



